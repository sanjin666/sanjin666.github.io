(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{512:function(v,_,t){"use strict";t.r(_);var s=t(6),n=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("CPU主要由"),t("strong",[v._v("运算器、控制器、寄存器组和内部总线")]),v._v("构成，我们知道运算器是用来完成运算的，而"),t("strong",[v._v("指令的执行就是在控制器中完成")]),v._v("的。\n 而控制器一般又包括指令控制逻辑、时序控制逻辑、总线控制逻辑和中断控制逻辑。更准确的说"),t("strong",[v._v("指令的执行是由指令控制逻辑完成")]),v._v("的，下面先看一下指令控制逻辑的组成。")]),v._v(" "),t("h4",{attrs:{id:"指令控制逻辑的组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令控制逻辑的组成"}},[v._v("#")]),v._v(" 指令控制逻辑的组成")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sanjin666/imgHosting/vuepressimg/image-20210517083823542.png",alt:"image-20210517083823542"}})]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("指令寄存器")]),v._v("（IR）：用来暂存指令，当CPU执行指令时，先把它从内存取到缓冲寄存器中，再送入IR。然后指令译码器从IR中将指令取出来，进而分析指令。\n  2. "),t("strong",[v._v("程序计数器")]),v._v("（PC）：记住它保存的总是将要执行的下一条指令的地址即可。\n  程序的执行分两种情况：顺序执行和转移执行，如果程序是按顺序执行的，那么程序计数器只需要简单的加1就可以了；但是如果遇到转移指令，下一条指令的地址会根据当前指令的地址加上一个向前或向后的转移位移量得到或者根据转移指令给出的直接转移的地址得到。\n  3. "),t("strong",[v._v("地址寄存器")]),v._v("（AR）：保存当前CPU所访问的内存单元地址。由于内存和CPU在操作速度上的差异，所以需要用AR保存地址信息，知道内存的读写操作完成为止。")]),v._v(" "),t("li",[t("strong",[v._v("指令译码器")]),v._v("（ID）：用来分析指令。指令包括操作码和地址码两部分，指令译码器就是对操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出控制信号，完成所需功能。")])]),v._v(" "),t("h3",{attrs:{id:"指令的执行过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令的执行过程"}},[v._v("#")]),v._v(" 指令的执行过程")]),v._v(" "),t("p",[v._v("几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数、结果写回。")]),v._v(" "),t("p",[t("strong",[v._v("1．取指令阶段")])]),v._v(" "),t("p",[v._v("取指令（Instruction Fetch，IF）阶段是将一条指令从主存中取到指令寄存器的过程。")]),v._v(" "),t("p",[v._v("程序计数器PC中的数值，用来指示当前指令在主存中的位置。当一条指令被取出后，PC中的数值将根据指令字长度而自动递增：若为单字长指令，则(PC)+1àPC；若为双字长指令，则(PC)+2àPC，依此类推。")]),v._v(" "),t("p",[t("strong",[v._v("2．指令译码阶段")])]),v._v(" "),t("p",[v._v("取出指令后，计算机立即进入指令译码（Instruction Decode，ID）阶段。")]),v._v(" "),t("p",[v._v("在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。")]),v._v(" "),t("p",[t("strong",[v._v("3．执行指令阶段")])]),v._v(" "),t("p",[v._v("在取指令和指令译码阶段之后，接着进入执行指令（Execute，EX）阶段。")]),v._v(" "),t("p",[v._v("此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。为此，CPU的不同部分被连接起来，以执行所需的操作。")]),v._v(" "),t("p",[v._v("例如，如果要求完成一个加法运算，算术逻辑单元ALU将被连接到一组输入和一组输出，输入端提供需要相加的数值，输出端将含有最后的运算结果。")]),v._v(" "),t("p",[t("strong",[v._v("4．访存取数阶段")])]),v._v(" "),t("p",[v._v("根据指令需要，有可能要访问主存，读取操作数，这样就进入了访存取数（Memory，MEM）阶段。")]),v._v(" "),t("p",[v._v("此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。")]),v._v(" "),t("p",[t("strong",[v._v("5．结果写回阶段")])]),v._v(" "),t("p",[v._v("作为最后一个阶段，结果写回（Writeback，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：结果数据经常被写到CPU的内部寄存器中，以便被后续的指令快速地存取；在有些情况下，结果数据也可被写入相对较慢、但较廉价且容量较大的主存。许多指令还会改变程序状态字寄存器中标志位的状态，这些标志位标识着不同的操作结果，可被用来影响程序的动作。")]),v._v(" "),t("p",[v._v("在指令执行完毕、结果数据写回之后，若无意外事件（如结果溢出等）发生，计算机就接着从程序计数器PC中取得下一条指令地址，开始新一轮的循环，下一个指令周期将顺序取出下一条指令。")]),v._v(" "),t("p",[v._v("许多新型CPU可以同时取出、译码和执行多条指令，体现并行处理的特性。")])])}),[],!1,null,null,null);_.default=n.exports}}]);