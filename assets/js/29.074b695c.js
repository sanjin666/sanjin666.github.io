(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{523:function(t,_,v){"use strict";v.r(_);var s=v(6),r=Object(s.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"tcp和udp的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[t._v("#")]),t._v(" TCP和UDP的区别？")]),t._v(" "),v("p",[t._v("TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：")]),t._v(" "),v("p",[t._v("TCP是面向连接的，UDP是无连接的；")]),t._v(" "),v("p",[t._v("TCP是可靠的，UDP是不可靠的；")]),t._v(" "),v("p",[t._v("TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；")]),t._v(" "),v("p",[t._v("TCP是面向字节流的，UDP是面向报文的；")]),t._v(" "),v("p",[t._v("TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；")]),t._v(" "),v("p",[t._v("TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sanjin666/imgHosting/vuepressimg/image-20210502180434867.png",alt:"image-20210502180434867"}})]),t._v(" "),v("p",[v("strong",[t._v("TCP报文：")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sanjin666/imgHosting/vuepressimg/1366161483_3725.jpg",alt:"1366161483_3725"}})]),t._v(" "),v("h2",{attrs:{id:"tcp如何保证可靠传输"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp如何保证可靠传输"}},[t._v("#")]),t._v(" TCP如何保证可靠传输？")]),t._v(" "),v("p",[t._v("TCP提供一种面向连接的、可靠的字节流服务。TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、 拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。")]),t._v(" "),v("p",[t._v("具体的：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("应用数据被分割成 TCP 认为最适合发送的数据块。")])]),t._v(" "),v("li",[v("p",[t._v("TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("校验和:")]),t._v(" TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。")])]),t._v(" "),v("li",[v("p",[t._v("TCP 的接收端会丢弃重复的数据。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("流量控制:")]),t._v(" TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是"),v("strong",[t._v("可变大小的滑动窗口协议")]),t._v("。 (TCP 利用滑动窗口实现流量控制)")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("拥塞控制:")]),t._v(" 当网络拥塞时，减少数据的发送。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("ARQ协议:")]),t._v(" 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。如果没收到就重新发送。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("超时重传:")]),t._v(" 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。")])])]),t._v(" "),v("h2",{attrs:{id:"arq协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arq协议"}},[t._v("#")]),t._v(" ARQ协议")]),t._v(" "),v("p",[v("strong",[t._v("自动重传请求")]),t._v("(Automatic Repeat-reQuest，ARQ)是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。 如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ 协议和连续ARQ协议。")]),t._v(" "),v("h3",{attrs:{id:"停止等待arq协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#停止等待arq协议"}},[t._v("#")]),t._v(" 停止等待"),v("strong",[t._v("ARQ")]),t._v("协议")]),t._v(" "),v("p",[t._v("停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认(回复ACK)。如果过了一段时间(超时时间后)，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组; 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认;")]),t._v(" "),v("p",[t._v("优点: 简单\n缺点: 信道利用率低，等待时间⻓")]),t._v(" "),v("h3",{attrs:{id:"连续arq协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#连续arq协议"}},[t._v("#")]),t._v(" 连续"),v("strong",[t._v("ARQ")]),t._v("协议")]),t._v(" "),v("p",[t._v("连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连 续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发 送确认，表明到这个分组为止的所有分组都已经正确收到了。")]),t._v(" "),v("p",[v("strong",[t._v("优点:")]),t._v(" 信道利用率高，容易实现，即使确认丢失，也不必重传。")]),t._v(" "),v("p",[v("strong",[t._v("缺点:")]),t._v(" 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如:发送方发送了 5条 消息，中间第三条丢失(3号)，这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N(回退 N)，表示需要退回来重传 已经发送过的 N 个消息。")]),t._v(" "),v("h2",{attrs:{id:"滑动窗口和流量控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口和流量控制"}},[t._v("#")]),t._v(" 滑动窗口和流量控制")]),t._v(" "),v("p",[v("strong",[t._v("TCP")]),t._v(" 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。")]),t._v(" "),v("p",[t._v("接收端抑制发送端的依据：接收端缓冲区的大小")]),t._v(" "),v("p",[t._v("流量控制的机制是丢包")]),t._v(" "),v("p",[t._v("操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉")]),t._v(" "),v("p",[t._v("（5）接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端，发送端收到这个值后，就会减慢自己的发送速度\n（6）如果接收端发现自己的缓冲区满了，就会将窗口的大小设置为0，此时发送端将不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端\nps：在TCP的首部中，有一个16为窗口字段，此字段就是用来存放窗口大小信息的")]),t._v(" "),v("h2",{attrs:{id:"拥塞控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制"}},[t._v("#")]),t._v(" 拥塞控制")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://blog.csdn.net/qq_41431406/article/details/97926927?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162044685216780269891924%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162044685216780269891924&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-97926927.first_rank_v2_pc_rank_v29&utm_term=TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6&spm=1018.2226.3001.4187",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考文献"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sanjin666/imgHosting/vuepressimg/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg",alt:"img"}})]),t._v(" "),v("p",[t._v("在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制\n所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。")]),t._v(" "),v("p",[t._v("为了进行拥塞控制，TCP 发送方要维持一个 "),v("strong",[t._v("拥塞窗口(cwnd)")]),t._v(" 的状态变量。拥塞控制窗口的大小 取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受 窗口中较小的一个。")]),t._v(" "),v("p",[t._v("TCP的拥塞控制采用了四种算法，即 "),v("strong",[t._v("慢开始")]),t._v(" 、 "),v("strong",[t._v("拥塞避免")]),t._v(" 、"),v("strong",[t._v("快重传")]),t._v(" 和 "),v("strong",[t._v("快恢复")]),t._v("。在网络层也可以 使路由器采用适当的分组丢弃策略(如主动队列管理 AQM)，以减少网络拥塞的发生。")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("慢开始:")]),t._v(" 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网 络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，􏶡好的方法 是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。 cwnd初始值为1，每经过一个传播轮次，cwnd加倍。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("拥塞避免:")]),t._v(" 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT 就把发送放的cwnd加1.")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("快重传与快恢复:")])]),t._v(" "),v("p",[t._v("在 TCP/IP 中，快速重传和恢复(fast retransmit and recovery，FRR)是一种拥塞控制算 法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来 要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果 接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接 收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。 有了 FRR，就不会因为重传时要求的暂停被耽误。  当有单独的数据包丢失时，快速重传 和恢复(FRR)能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则 不能很有效地工作。")])])]),t._v(" "),v("h2",{attrs:{id:"ddos-distributed-denial-of-service-攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ddos-distributed-denial-of-service-攻击"}},[t._v("#")]),t._v(" DDos(Distributed Denial of Service)攻击？")]),t._v(" "),v("p",[t._v("SYN flood在攻击时，首先伪造大量的源IP地址，分别向服务器端发送大量的SYN包，此时服务器端会返回SYN/ACK包，因为源地址时伪造的，所以伪造的IP并不会应答，服务器端没有收到伪造IP的回应，会重试3-5次并且等待一个SYN Time(一般为30秒至2分钟)，如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的SYN请求，服务端将会消耗非常多的资源(CPU和内存)来处理这种半连接，同时还要不断地对这些IP进行SYN+ACK重试，最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。")]),t._v(" "),v("p",[t._v("对抗SYN flood的主要措施有SYN Cookie/SYN Proxy、safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。")])])}),[],!1,null,null,null);_.default=r.exports}}]);