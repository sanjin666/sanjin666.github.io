(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{526:function(e,v,_){"use strict";_.r(v);var t=_(6),s=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("p",[_("a",{attrs:{href:"https://www.zhihu.com/question/300767410/answer/1749442787",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("如果在一个分布式系统中，我们从数据库中读取一个数据，然后修改保存，这种情况很容易遇到并发问题。因为读取和更新保存不是一个原子操作，在并发时就会导致数据的不正确。这种场景其实并不少见，比如电商秒杀活动，库存数量的更新就会遇到。如果是单机应用，直接使用本地锁就可以避免。如果是分布式应用，本地锁派不上用场，这时就需要引入分布式锁来解决。")]),e._v(" "),_("p",[e._v("**分布式锁目的：**为了保证多台服务器在执行某一段代码时保证只有一台服务器执行。")]),e._v(" "),_("p",[e._v("实现分布式锁需要满足三个条件：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("**互斥性：**在任何时刻，保证只有一个客户端持有锁。")])]),e._v(" "),_("li",[_("p",[e._v("**不能出现死锁：**如果在一个客户端持有锁的期间，这个客户端崩溃了，也要保证后续的其他客户端可以上锁。")])])]),e._v(" "),_("ul",[_("li",[_("strong",[e._v("保证上锁和解锁都是同一个客户端。")])])]),e._v(" "),_("p",[e._v("一般来说，实现分布式锁的方式有以下几种：")]),e._v(" "),_("ul",[_("li",[e._v("使用MySQL，基于唯一索引。")]),e._v(" "),_("li",[e._v("使用ZooKeeper，基于临时有序节点。")]),e._v(" "),_("li",[_("strong",[e._v("使用Redis，基于setnx命令")]),e._v("。（不能实现严格意义上的分布式锁）")])]),e._v(" "),_("h3",{attrs:{id:"redis分布式锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁"}},[e._v("#")]),e._v(" Redis分布式锁")]),e._v(" "),_("p",[e._v("加锁：使用"),_("code",[e._v("setnx key value")]),e._v("命令，如果key不存在，设置value(加锁成功)。如果已经存在lock(也就是有客户端持有锁了)，则设置失败(加锁失败)。")]),e._v(" "),_("p",[e._v("解锁：使用"),_("code",[e._v("del")]),e._v("命令，通过删除键值释放锁。释放锁之后，其他客户端可以通过"),_("code",[e._v("setnx")]),e._v("命令进行加锁。")]),e._v(" "),_("p",[e._v("**超时机制： **避免死锁。设定时长：1、程序员自己把握。2、给锁续期")]),e._v(" "),_("p",[e._v("**可重入：**使用Redis的哈希表存储可重入次数，当加锁成功后，使用"),_("code",[e._v("hset")]),e._v("命令，value(重入次数)则是1。")]),e._v(" "),_("p",[e._v("**发布订阅：**为了避免加锁失败下一直轮询尝试消耗性能，利用发布订阅的机制进行性能优化")])])}),[],!1,null,null,null);v.default=s.exports}}]);