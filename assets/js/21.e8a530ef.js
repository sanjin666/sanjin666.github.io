(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{515:function(t,a,s){"use strict";s.r(a);var r=s(6),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"cap理论"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cap理论"}},[t._v("#")]),t._v(" CAP理论")]),t._v(" "),s("p",[s("strong",[t._v("Consistency ：")]),t._v(" 一致性，所有节点在同一时间具有相同的数据")]),t._v(" "),s("p",[s("strong",[t._v("Availability ：")]),t._v(" 可用性，保证每个请求不管成功或者失败都有响应")]),t._v(" "),s("p",[t._v("**Partition tolerance : ** 分割容忍，系统中任意信息的丢失或失败不会影响系统的继续运作")]),t._v(" "),s("p",[s("strong",[t._v("CAP三者不可兼得，该如何取舍：")])]),t._v(" "),s("p",[t._v("(1) CA: 优先保证一致性和可用性，放弃分区容错。 这也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。")]),t._v(" "),s("p",[t._v("(2) CP: 优先保证一致性和分区容错性，放弃可用性。在数据一致性要求比较高的场合(譬如:zookeeper,Hbase) 是比较常见的做法，一旦发生网络故障或者消息丢失，就会牺牲用户体验，等恢复之后用户才逐渐能访问。")]),t._v(" "),s("p",[t._v("(3) AP: 优先保证可用性和分区容错性，放弃一致性。NoSQL中的Cassandra 就是这种架构。跟CP一样，放弃一致性不是说一致性就不保证了，而是逐渐的变得一致。")]),t._v(" "),s("h3",{attrs:{id:"注册中心"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注册中心"}},[t._v("#")]),t._v(" 注册中心")]),t._v(" "),s("h3",{attrs:{id:"配置中心"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置中心"}},[t._v("#")]),t._v(" 配置中心")]),t._v(" "),s("p",[t._v("比如同一个的服务分布在不同的服务器上， 每一个服务器都有一个配置文件，修改起来很麻烦，Nacos 可以统一配置文件")])])}),[],!1,null,null,null);a.default=e.exports}}]);