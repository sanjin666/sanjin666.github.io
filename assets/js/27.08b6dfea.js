(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{521:function(s,o,i){"use strict";i.r(o);var e=i(6),n=Object(e.a)({},(function(){var s=this,o=s.$createElement,i=s._self._c||o;return i("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[i("h4",{attrs:{id:"session、cookie"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#session、cookie"}},[s._v("#")]),s._v(" Session、Cookie")]),s._v(" "),i("p",[s._v("HTTP 的无状态性简化了服务器设计，提高了性能，使其可以同时处理大量 TCP 连接。但无状态也导致服务器不能识别用户，Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。")]),s._v(" "),i("p",[s._v("**Cookie：**Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。")]),s._v(" "),i("p",[s._v("**Session：**同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 cookie机制 ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 URL重写机制 将sessionid传回服务器。")]),s._v(" "),i("p",[i("strong",[s._v("Cookie、Session的区别：")])]),s._v(" "),i("ul",[i("li",[i("p",[i("strong",[s._v("应用场景")]),s._v(" Cookie 一般用来保存用户信息，  Session 的 主要作用就是通过服务端记录用户的状态。")])]),s._v(" "),i("li",[i("p",[s._v("**实现机制：**Session的实现常常依赖于Cookie机制，session id 存在 cookie 中，叫做 JSESSIONID。如果浏览器禁用了 cookie ，同时 session 也会失效；")])]),s._v(" "),i("li",[i("p",[s._v("**大小类型限制：**Cookie只能存储ASCII码，有大小限制并且浏览器对每个站点也有cookie的个数限制，Session可以存储任何类型的数据，没有大小限制，理论上只与服务器的内存大小有关；")])]),s._v(" "),i("li",[i("p",[s._v("**安全性：**Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；")])]),s._v(" "),i("li",[i("p",[s._v("**服务器资源消耗：**Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。")])])])])}),[],!1,null,null,null);o.default=n.exports}}]);