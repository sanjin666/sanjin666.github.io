(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{520:function(a,t,s){"use strict";s.r(t);var h=s(6),l=Object(h.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"hashmap数组容量为什么要设计成-2-n"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap数组容量为什么要设计成-2-n"}},[a._v("#")]),a._v(" HashMap数组容量为什么要设计成 $2^n$  ?")]),a._v(" "),s("h3",{attrs:{id:"hashmap-1-7-和-1-8-的区别-或者1-8有哪些优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-1-7-和-1-8-的区别-或者1-8有哪些优化"}},[a._v("#")]),a._v(" HashMap 1.7 和 1.8 的区别 ？（或者1.8有哪些优化？）")]),a._v(" "),s("ul",[s("li",[a._v("底层数据结构从“数组+链表”改成“数组+链表+红黑树”，主要是优化了 hash 冲突较严重时，链表过长的查找性能：O(n) -> O(logn)")]),a._v(" "),s("li",[a._v("1.8 计算 table 初始容量的方式更加优雅，1.7 是从1开始不断向左进行移位运算，直到找到大于等于入参容量的值；新的方式则是通过“5个移位 + 或等于运算 ” 来计算")]),a._v(" "),s("li",[a._v("优化了 hash 值的计算方式，1.7 是一通移位操作加异或运算，1.8 只是简单的让高16位参与了运算")]),a._v(" "),s("li",[a._v("扩容时插入方式从 1.7 的“头插法”改成 1.8 的 “尾插法”，避免了并发下的死循环")]),a._v(" "),s("li",[a._v("扩容时计算节点在新表的索引位置方式从“h & (length-1)”改成“hash & oldCap”，性能可能提升不大，但设计更巧妙、更优雅")]),a._v(" "),s("li",[s("strong",[a._v("在扩容的时候：1.7在插入数据之前扩容，而1.8插入数据成功之后扩容。")])])])])}),[],!1,null,null,null);t.default=l.exports}}]);