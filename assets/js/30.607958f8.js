(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{524:function(t,v,_){"use strict";_.r(v);var s=_(6),r=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"题一、描述三次握手流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题一、描述三次握手流程"}},[t._v("#")]),t._v(" 题一、描述三次握手流程 ?")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sanjin666/imgHosting/vuepressimg/three.png",alt:"three"}})]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。")])])]),t._v(" "),_("ol",[_("li",[t._v("TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；")]),t._v(" "),_("li",[t._v("TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。")]),t._v(" "),_("li",[t._v("TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。")]),t._v(" "),_("li",[t._v("TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。")]),t._v(" "),_("li",[t._v("当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。")])]),t._v(" "),_("h3",{attrs:{id:"题二、为什么要三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题二、为什么要三次握手"}},[t._v("#")]),t._v(" 题二、为什么要三次握手?")]),t._v(" "),_("p",[t._v("三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握\n手最主要的目的就是双方确认自己与对方的发送与接收是正常的。")]),t._v(" "),_("p",[t._v("第一次握手 : Client 什么都不能确认 ;")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t\tServer 确认了对方发送正常，自己接收正常")]),t._v(" "),_("p",[t._v("第二次握手 : Client 确认了 : 自己发送、接收正常，对方发送、接收正常;")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t\tServer 确认了:对方发送正常，自己接收正常")]),t._v(" "),_("p",[t._v("第三次握手 : Client 确认了 : 自己发送、接收正常，对方发送、接收正常;")]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t\tServer 确认了 : 自己发送、接收正常，对方发送、接收正常；")]),t._v(" "),_("p",[t._v("所以三次握手就能确认双发收发功能都正常，缺一不可。")]),t._v(" "),_("h3",{attrs:{id:"题三、为什么客户端要进行最后一次确认"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题三、为什么客户端要进行最后一次确认"}},[t._v("#")]),t._v(" 题三、为什么客户端要进行最后一次确认?")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("为了防止已经失效的请求再次到达服务器产生错误")])])]),t._v(" "),_("p",[t._v("如果采用两次握手，假定一种场景，网络拥塞导致客户端发送请求长期滞留在网络，客户端会因为长期没有收到确认报文而重新发送，然后客户端和服务器经过两次握手完成连接，传完数据而后关闭连接。这时第一次滞留在网络的报文到达服务器，按道理这个报文应该失效，但是因为两次握手的机制，这时服务器又返回确认报文导致再次建立连接，"),_("strong",[t._v("造成资源的浪费")]),t._v("。")]),t._v(" "),_("p",[t._v("如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，"),_("strong",[t._v("但是客户端不会再次发出确认")]),t._v("。由于服务器收不到确认，就知道客户端并没有请求连接。从而避免了再次建立无效的连接。而客户端不会再次发送确认是通过通信双方维护的"),_("strong",[t._v("序列号")]),t._v("来实现。")]),t._v(" "),_("h3",{attrs:{id:"题四、描述四次挥手的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题四、描述四次挥手的流程"}},[t._v("#")]),t._v(" 题四、描述四次挥手的流程？")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/sanjin666/imgHosting/vuepressimg/four.png",alt:"四次挥手"}})]),t._v(" "),_("ol",[_("li",[t._v("客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。")]),t._v(" "),_("li",[t._v("服务器收到连接释放报文，发出确认报文，"),_("strong",[t._v("ACK=1，ack=u+1")]),t._v("，并且带上自己的序列号"),_("strong",[t._v("seq=v")]),t._v("，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。")]),t._v(" "),_("li",[t._v("客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。")]),t._v(" "),_("li",[t._v("服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，"),_("strong",[t._v("FIN=1，ack=u+1")]),t._v("，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为"),_("strong",[t._v("seq=w")]),t._v("，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。")]),t._v(" "),_("li",[t._v("客户端收到服务器的连接释放报文后，必须发出确认，"),_("strong",[t._v("ACK=1，ack=w+1")]),t._v("，而自己的序列号是"),_("strong",[t._v("seq=u+1")]),t._v("，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，"),_("strong",[t._v("必须经过2 MSL（最长报文段寿命）的时间后")]),t._v("，当客户端撤销相应的TCB后，才进入CLOSED状态。")]),t._v(" "),_("li",[t._v("服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。")])]),t._v(" "),_("h3",{attrs:{id:"题五、为什么客户端最后还要等待2msl"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题五、为什么客户端最后还要等待2msl"}},[t._v("#")]),t._v(" 题五、为什么客户端最后还要等待2MSL？")]),t._v(" "),_("p",[t._v("MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。\n第一，"),_("strong",[t._v("保证客户端发送的最后一个ACK报文能够到达服务器")]),t._v("，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，"),_("strong",[t._v("而客户端就能在这个2MSL时间段内收到这个重传的报文")]),t._v("，接着给出回应报文，并且"),_("strong",[t._v("会重启2MSL计时器")]),t._v("。\n第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，"),_("strong",[t._v("在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。")])]),t._v(" "),_("p",[_("a",{attrs:{href:"https://blog.csdn.net/qzcsu/article/details/72861891",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考博客"),_("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=r.exports}}]);