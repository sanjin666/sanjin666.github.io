(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{511:function(v,_,r){"use strict";r.r(_);var t=r(6),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h3",{attrs:{id:"堆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),r("p",[v._v("Java 虚拟机所管理的"),r("strong",[v._v("内存中最大")]),v._v("的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是"),r("strong",[v._v("存放对象实例")]),v._v("，几乎所有的对象实例以及数组都在这里 配内存。")]),v._v(" "),r("p",[r("strong",[v._v("Java")]),v._v("世界中**“"),r("strong",[v._v("几乎")]),v._v("”"),r("strong",[v._v("所有的对象都在堆中分配，但是，随着")]),v._v("JIT"),r("strong",[v._v("编译期的发展与")]),v._v("逃逸分析技术"),r("strong",[v._v("逐渐 成熟，"),r("strong",[v._v("栈上分配、标量替换优化技术")]),v._v("将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐 变得不那么")]),v._v("“"),r("strong",[v._v("绝对")]),v._v("”"),r("strong",[v._v("了。从")]),v._v("jdk 1.7"),r("strong",[v._v("开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被 返回或者未被外面使用(也就是未逃逸出去)，那么")]),v._v("对象可以直接在栈上分配内存**。")]),v._v(" "),r("p",[v._v("Java 堆是垃圾收集器管理的"),r("strong",[v._v("主要区域")]),v._v("，因此也被称作"),r("strong",[v._v("GC")]),v._v(" 堆("),r("strong",[v._v("Garbage Collected Heap")]),v._v(").从垃圾回收的⻆度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为:新 生代和老年代:再细致一点有:Eden 空间、From Survivor、To Survivor 空间等。进一步划分的 目的是更好地回收内存，或者更快地分配内存。")]),v._v(" "),r("h3",{attrs:{id:"方法区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[v._v("#")]),v._v(" 方法区")]),v._v(" "),r("p",[v._v("方法区是一个"),r("strong",[v._v("概念")]),v._v("， 实现有"),r("strong",[v._v("永久代（JDK1.6，1.7）和元空间（JDK1.8）")])]),v._v(" "),r("p",[v._v("元空间的本质和永久代类似,都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于:元空间不在虚拟机设置的内存中,而是使用本地内存。")]),v._v(" "),r("p",[r("strong",[v._v("方法区存储：")]),v._v(" "),r("strong",[v._v("类型信息")]),v._v("、"),r("strong",[v._v("常量")]),v._v("、"),r("strong",[v._v("静态变量")]),v._v("、"),r("strong",[v._v("即时编译器编译后的代码缓存")])]),v._v(" "),r("ul",[r("li",[r("p",[v._v("JDK1.6：静态变量，字符串常量池存储在"),r("strong",[v._v("永久代")])])]),v._v(" "),r("li",[r("p",[v._v("JDK1.7，1.8 ： 静态变量，字符串常量池存储在"),r("strong",[v._v("堆")])])])]),v._v(" "),r("h3",{attrs:{id:"程序计数器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[v._v("#")]),v._v(" 程序计数器")]),v._v(" "),r("p",[v._v("程序计数器是一块"),r("strong",[v._v("较小的内存空间")]),v._v("，可以看作是"),r("strong",[v._v("当前线程所执行的字节码的行号指示器")]),v._v("。字节码"),r("strong",[v._v("解释器")]),v._v("工作时通过改变这个计数器的值来"),r("strong",[v._v("选取下一条需要执行的字节码指令")]),v._v("，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计时器来完成。")]),v._v(" "),r("p",[v._v("为了"),r("strong",[v._v("线程切换后能恢复到正确的执行位置")]),v._v("，每条线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“"),r("strong",[v._v("线程私有")]),v._v("”的内存。")]),v._v(" "),r("p",[v._v("程序计数器是"),r("strong",[v._v("唯一一个")]),v._v("不会出现 "),r("strong",[v._v("OutOfMemoryError")]),v._v(" 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。")]),v._v(" "),r("h3",{attrs:{id:"java-虚拟机栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机栈"}},[v._v("#")]),v._v(" "),r("strong",[v._v("Java")]),v._v(" 虚拟机栈")]),v._v(" "),r("p",[v._v("与程序计数器一样，"),r("strong",[v._v("Java")]),v._v(" 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 "),r("strong",[v._v("Java")]),v._v("方法执行的内存模型，每次方法调用的数据都是通过栈传递的。")]),v._v(" "),r("p",[r("strong",[v._v("Java")]),v._v(" 内存可以粗糙的区分为堆内存("),r("strong",[v._v("Heap")]),v._v(")和栈内存 **(Stack),**其中栈就是现在说的虚拟机栈， 或者说是虚拟机栈中局部变量表部分。 (实际上，Java 虚拟机栈是由一个个栈帧组成，而每个 栈帧中都拥有:局部变量表、操作数栈、动态链接、方法出口信息。)")]),v._v(" "),r("p",[v._v("局部变量表主要存放了编译期可知的各种数据类型(boolean、byte、char、short、int、float、 long、double)、对象引用(reference 类型，它不同于对象本身，可能是一个指向对象起始地址 的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)。")]),v._v(" "),r("p",[r("strong",[v._v("Java")]),v._v(" 虚拟机栈会出现两种错误: "),r("strong",[v._v("StackOverFlowError")]),v._v(" 和 "),r("strong",[v._v("OutOfMemoryError")]),v._v(" 。")]),v._v(" "),r("p",[r("strong",[v._v("StackOverFlowError")]),v._v(" : 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈 的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。")]),v._v(" "),r("p",[r("strong",[v._v("OutOfMemoryError")]),v._v(" : 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多 内存的话。就会抛出 OutOfMemoryError 错误。")]),v._v(" "),r("p",[v._v("Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创 建，随着线程的死亡而死亡。")]),v._v(" "),r("p",[v._v("扩展:那么方法函数如何调用?")]),v._v(" "),r("p",[v._v("Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个 对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。")]),v._v(" "),r("p",[v._v("Java 方法有两种返回方式:")]),v._v(" "),r("ol",[r("li",[v._v("return 语句")]),v._v(" "),r("li",[v._v("抛出异常。")])]),v._v(" "),r("p",[v._v("不管哪种返回方式都会导致栈帧被弹出。")]),v._v(" "),r("h3",{attrs:{id:"本地方法栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[v._v("#")]),v._v(" 本地方法栈")]),v._v(" "),r("p",[v._v("和虚拟机栈所发挥的作用非常相似，区别是: 虚拟机栈为虚拟机执行 "),r("strong",[v._v("Java")]),v._v(" 方法 (也就是字节 码)服务，而本地方法栈则为虚拟机使用到的 "),r("strong",[v._v("Native")]),v._v(" 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。")]),v._v(" "),r("p",[v._v("本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。")]),v._v(" "),r("p",[v._v("方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。")])])}),[],!1,null,null,null);_.default=a.exports}}]);